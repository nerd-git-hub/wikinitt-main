package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"

	"github.com/pranava-mohan/wikinitt/gravy/graph/model"
	"github.com/pranava-mohan/wikinitt/gravy/internal/maplocation"
)

// AddMapLocation is the resolver for the addMapLocation field.
func (r *mutationResolver) AddMapLocation(ctx context.Context, input model.MapLocationInput) (*model.MapLocation, error) {
	var menu []maplocation.MenuItem
	if input.Menu != nil {
		for _, item := range input.Menu {
			if item != nil {
				menu = append(menu, maplocation.MenuItem{
					Item:  item.Item,
					Price: item.Price,
				})
			}
		}
	}

	var description string
	if input.Description != nil {
		description = *input.Description
	}

	loc := &maplocation.MapLocation{
		Name:        input.Name,
		Type:        input.Type,
		Coordinates: input.Coordinates,
		Description: description,
		Menu:        menu,
	}

	if err := r.MapLocationRepo.Create(ctx, loc); err != nil {
		return nil, err
	}

	// Convert back to model
	var modelMenu []*model.MenuItem
	for _, m := range loc.Menu {
		modelMenu = append(modelMenu, &model.MenuItem{
			Item:  m.Item,
			Price: m.Price,
		})
	}

	desc := loc.Description

	return &model.MapLocation{
		ID:          loc.ID.Hex(),
		Name:        loc.Name,
		Type:        loc.Type,
		Coordinates: loc.Coordinates,
		Description: &desc,
		Menu:        modelMenu,
	}, nil
}

// DeleteMapLocation is the resolver for the deleteMapLocation field.
func (r *mutationResolver) DeleteMapLocation(ctx context.Context, id string) (bool, error) {
	err := r.MapLocationRepo.Delete(ctx, id)
	return err == nil, err
}

// MapLocations is the resolver for the mapLocations field.
func (r *queryResolver) MapLocations(ctx context.Context) ([]*model.MapLocation, error) {
	locs, err := r.MapLocationRepo.List(ctx)
	if err != nil {
		return nil, err
	}

	var result []*model.MapLocation
	for _, l := range locs {
		var menu []*model.MenuItem
		for _, m := range l.Menu {
			menu = append(menu, &model.MenuItem{
				Item:  m.Item,
				Price: m.Price,
			})
		}

		desc := l.Description

		result = append(result, &model.MapLocation{
			ID:          l.ID.Hex(),
			Name:        l.Name,
			Type:        l.Type,
			Coordinates: l.Coordinates,
			Description: &desc,
			Menu:        menu,
		})
	}
	return result, nil
}
