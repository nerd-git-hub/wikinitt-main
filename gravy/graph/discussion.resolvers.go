package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"time"

	"github.com/pranava-mohan/wikinitt/gravy/graph/model"
	"github.com/pranava-mohan/wikinitt/gravy/internal/auth"
	"github.com/pranava-mohan/wikinitt/gravy/internal/community"
	"github.com/pranava-mohan/wikinitt/gravy/internal/sanitization"
	"github.com/pranava-mohan/wikinitt/gravy/internal/users"
)

// Messages is the resolver for the messages field.
func (r *channelResolver) Messages(ctx context.Context, obj *model.Channel, limit *int32, offset *int32) ([]*model.Message, error) {
	l := 50
	o := 0
	if limit != nil {
		l = int(*limit)
	}
	if offset != nil {
		o = int(*offset)
	}

	messages, err := r.CommunityRepo.ListMessages(ctx, obj.ID, l, o)
	if err != nil {
		return nil, err
	}

	var modelMessages []*model.Message
	for _, m := range messages {
		sender, _ := r.UserRepo.GetByID(ctx, m.SenderID)
		modelMessages = append(modelMessages, &model.Message{
			ID:        m.ID,
			Content:   m.Content,
			Sender:    mapPublicUserToModel(mapUserToPublic(sender)),
			CreatedAt: m.CreatedAt.Format("2006-01-02 15:04:05"),
		})
	}
	return modelMessages, nil
}

// Channels is the resolver for the channels field.
func (r *discussionResolver) Channels(ctx context.Context, obj *model.Discussion) ([]*model.Channel, error) {
	channels, err := r.CommunityRepo.ListChannels(ctx, obj.ID)
	if err != nil {
		return nil, err
	}
	var modelChannels []*model.Channel
	for _, c := range channels {
		modelChannels = append(modelChannels, &model.Channel{
			ID:   c.ID,
			Name: c.Name,
			Type: model.ChannelType(c.Type),
		})
	}
	return modelChannels, nil
}

// CreateChannel is the resolver for the createChannel field.
func (r *mutationResolver) CreateChannel(ctx context.Context, input model.NewChannel) (*model.Channel, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	discussion, err := r.CommunityRepo.GetDiscussion(ctx, input.DiscussionID)
	if err != nil {
		return nil, err
	}
	if discussion == nil {
		return nil, fmt.Errorf("discussion not found")
	}

	group, err := r.CommunityRepo.GetGroupByID(ctx, discussion.GroupID)
	if err != nil {
		return nil, err
	}
	if group.OwnerID != user.ID {
		return nil, fmt.Errorf("access denied: only group owner can create channels")
	}

	channel := &community.Channel{
		DiscussionID: input.DiscussionID,
		Name:         input.Name,
		Type:         community.ChannelType(input.Type),
		CreatedAt:    time.Now(),
	}

	err = r.CommunityRepo.CreateChannel(ctx, channel)
	if err != nil {
		return nil, err
	}

	return &model.Channel{
		ID:   channel.ID,
		Name: channel.Name,
		Type: model.ChannelType(channel.Type),
	}, nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, input model.NewMessage) (*model.Message, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	channel, err := r.CommunityRepo.GetChannel(ctx, input.ChannelID)
	if err != nil {
		return nil, err
	}
	if channel == nil {
		return nil, fmt.Errorf("channel not found")
	}

	discussion, err := r.CommunityRepo.GetDiscussion(ctx, channel.DiscussionID)
	if err != nil {
		return nil, err
	}
	if discussion == nil {
		return nil, fmt.Errorf("discussion not found")
	}

	isMember, err := r.CommunityRepo.IsMember(ctx, discussion.GroupID, user.ID)
	if err != nil {
		return nil, err
	}
	if !isMember {
		return nil, fmt.Errorf("access denied: only group members can send messages")
	}

	message := &community.Message{
		ChannelID: input.ChannelID,
		SenderID:  user.ID,
		Content:   sanitization.SanitizeContent(input.Content),
		CreatedAt: time.Now(),
	}

	err = r.CommunityRepo.CreateMessage(ctx, message)
	if err != nil {
		return nil, err
	}

	sender := &users.PublicUser{
		ID:          user.ID,
		Name:        user.Name,
		Username:    user.Username,
		DisplayName: user.DisplayName,
		Gender:      user.Gender,
		Avatar:      user.Avatar,
	}

	return &model.Message{
		ID:        message.ID,
		Content:   message.Content,
		Sender:    mapPublicUserToModel(sender),
		CreatedAt: message.CreatedAt.Format("2006-01-02 15:04:05"),
	}, nil
}

// DeleteGroup is the resolver for the deleteGroup field.
func (r *mutationResolver) DeleteGroup(ctx context.Context, groupID string) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, fmt.Errorf("not authenticated")
	}

	fmt.Printf("DeleteGroup called for group %s by user %s\n", groupID, user.ID)
	group, err := r.CommunityRepo.GetGroupByID(ctx, groupID)
	if err != nil {
		fmt.Printf("Error fetching group: %v\n", err)
		return false, err
	}
	fmt.Printf("Group owner: %s\n", group.OwnerID)
	if group.OwnerID != user.ID {
		fmt.Printf("Access denied: owner %s != user %s\n", group.OwnerID, user.ID)
		return false, fmt.Errorf("access denied: only group owner can delete group")
	}

	err = r.CommunityRepo.DeleteGroup(ctx, groupID)
	if err != nil {
		fmt.Printf("Error deleting group: %v\n", err)
		return false, err
	}
	fmt.Println("Group deleted successfully")

	return true, nil
}

// Discussion is the resolver for the discussion field.
func (r *queryResolver) Discussion(ctx context.Context, groupID string) (*model.Discussion, error) {
	d, err := r.CommunityRepo.GetDiscussionByGroup(ctx, groupID)
	if err != nil {
		return nil, err
	}
	if d == nil {
		d = &community.Discussion{
			GroupID: groupID,
		}
		err = r.CommunityRepo.CreateDiscussion(ctx, d)
		if err != nil {
			return nil, err
		}
	}

	return &model.Discussion{
		ID: d.ID,
	}, nil
}

// Channel is the resolver for the channel field.
func (r *queryResolver) Channel(ctx context.Context, id string) (*model.Channel, error) {
	c, err := r.CommunityRepo.GetChannel(ctx, id)
	if err != nil {
		return nil, err
	}
	return &model.Channel{
		ID:   c.ID,
		Name: c.Name,
		Type: model.ChannelType(c.Type),
	}, nil
}

// MessageAdded is the resolver for the messageAdded field.
func (r *subscriptionResolver) MessageAdded(ctx context.Context, channelID string) (<-chan *model.Message, error) {
	return nil, fmt.Errorf("subscription not implemented yet")
}

// Channel returns ChannelResolver implementation.
func (r *Resolver) Channel() ChannelResolver { return &channelResolver{r} }

// Discussion returns DiscussionResolver implementation.
func (r *Resolver) Discussion() DiscussionResolver { return &discussionResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type channelResolver struct{ *Resolver }
type discussionResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
